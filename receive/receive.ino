#include <arduino-timer.h>

const int rx_pin = PC2;

// Hamming [8,4] extended-parity decoding
// High nybble : # of bit errors detected
// Low  nybble : data bits for this codeword
const byte hamming_to_nybble[256] = {
	0x00, 0x10, 0x10, 0x29, 0x10, 0x2e, 0x2b, 0x13, 0x10, 0x2e, 0x2d, 0x15, 0x2e, 0x1e, 0x17, 0x2e, 
	0x10, 0x29, 0x29, 0x19, 0x2a, 0x12, 0x17, 0x29, 0x2c, 0x14, 0x17, 0x29, 0x17, 0x2e, 0x07, 0x17, 
	0x10, 0x2e, 0x2d, 0x19, 0x2e, 0x1e, 0x1b, 0x2e, 0x2e, 0x1e, 0x1d, 0x2e, 0x1e, 0x0e, 0x2e, 0x1e, 
	0x2c, 0x19, 0x19, 0x09, 0x1a, 0x2e, 0x2b, 0x19, 0x1c, 0x2e, 0x2d, 0x19, 0x2e, 0x1e, 0x17, 0x2f, 
	0x10, 0x28, 0x2b, 0x15, 0x2b, 0x12, 0x1b, 0x2b, 0x2c, 0x15, 0x15, 0x05, 0x16, 0x2e, 0x2b, 0x15, 
	0x2c, 0x12, 0x11, 0x29, 0x12, 0x02, 0x2b, 0x12, 0x1c, 0x2c, 0x2c, 0x15, 0x2c, 0x12, 0x17, 0x2f, 
	0x2c, 0x18, 0x1b, 0x2b, 0x1b, 0x2e, 0x0b, 0x1b, 0x1c, 0x2e, 0x2d, 0x15, 0x2e, 0x1e, 0x1b, 0x2f, 
	0x1c, 0x2c, 0x2c, 0x19, 0x2c, 0x12, 0x1b, 0x2f, 0x0c, 0x1c, 0x1c, 0x2f, 0x1c, 0x2f, 0x2f, 0x1f, 
	0x10, 0x28, 0x2d, 0x13, 0x2a, 0x13, 0x13, 0x03, 0x2d, 0x14, 0x1d, 0x2d, 0x16, 0x2e, 0x2d, 0x13, 
	0x2a, 0x14, 0x11, 0x29, 0x1a, 0x2a, 0x2a, 0x13, 0x14, 0x04, 0x2d, 0x14, 0x2a, 0x14, 0x17, 0x2f, 
	0x2d, 0x18, 0x1d, 0x2d, 0x1a, 0x2e, 0x2d, 0x13, 0x1d, 0x2e, 0x0d, 0x1d, 0x2e, 0x1e, 0x1d, 0x2f, 
	0x1a, 0x2a, 0x2d, 0x19, 0x0a, 0x1a, 0x1a, 0x2f, 0x2d, 0x14, 0x1d, 0x2f, 0x1a, 0x2f, 0x2f, 0x1f, 
	0x28, 0x18, 0x11, 0x28, 0x16, 0x28, 0x2b, 0x13, 0x16, 0x28, 0x2d, 0x15, 0x06, 0x16, 0x16, 0x2f, 
	0x11, 0x28, 0x01, 0x11, 0x2a, 0x12, 0x11, 0x2f, 0x2c, 0x14, 0x11, 0x2f, 0x16, 0x2f, 0x2f, 0x1f, 
	0x18, 0x08, 0x2d, 0x18, 0x2b, 0x18, 0x1b, 0x2f, 0x2d, 0x18, 0x1d, 0x2f, 0x16, 0x2f, 0x2f, 0x1f, 
	0x2c, 0x18, 0x11, 0x2f, 0x1a, 0x2f, 0x2f, 0x1f, 0x1c, 0x2f, 0x2f, 0x1f, 0x2f, 0x1f, 0x1f, 0x0f, 
};

Timer<1, micros> timer;

#define BIT_DELAY_us 400
#define PACKET_BYTES 8

int threshold = 512;
byte data_buffer = 0;
byte data = 0;
int packet_index = 0;

// int bit_error_count;
// int error_count_start_ms;

bool sync_done;

int min = 1024, max = 0, bit_count = 0;
bool receive_bit() {
  bit_count++;
  int signal = analogRead(rx_pin);

  if ( !sync_done ) {
    if ( signal < min ) { min = signal; }
    if ( signal > max ) { max = signal; }
    if ( bit_count == 1000 ) {
      threshold = min + (max - min)*3/4;
      sync_done = true;
    }
  } else {
    data_buffer <<= 1;
    data_buffer |= (signal > threshold);
  }

  return true; // continue forever
}

void setup() {
  pinMode(rx_pin, INPUT_PULLUP);
  Serial.begin(115200);
  // set up fast ADC mode
  ADCSRA = (ADCSRA & 0xf8) | 0x04; // set 16 times division
  Serial.println("receiver initialized");
  timer.every( BIT_DELAY_us, receive_bit );
}

bool readingPacket = false;
bool firstNybble = true;

void loop() {
  timer.tick();

  if ( !readingPacket && data_buffer == 0xFF ) {
    readingPacket = true;
    packet_index = 0;
    bit_count = 0;
    data = 0;
    // Serial.println("packet:");
  } else if ( readingPacket && bit_count == 8 ) {

    if ( firstNybble ) {
      // Serial.print( data_buffer, HEX );
      // Serial.print(":");
      byte nybble = hamming_to_nybble[data_buffer];
      data = nybble << 4;
      // bit_error_count += (nybble >> 4);
    } else {
      // Serial.print( data_buffer, HEX );
      // Serial.print("|");
      byte nybble = hamming_to_nybble[data_buffer];
      data |= (nybble & 0x0F);
      Serial.print( (char)data );
      // Serial.println(data, HEX);
      // bit_error_count += (nybble >> 4);
      packet_index++;
    }

    firstNybble = !firstNybble;
    bit_count = 0;
    if ( packet_index == 8 ) {
      readingPacket = false;
    }
  }
}
